{"ast":null,"code":"/**\n * jTPS.java\n * \n * This class is used for managing an abstract transaction processing\n * system for the purpose of managing an undo/redo system for an\n * application. Note that one must specify all work done via custom\n * transactions.\n * \n * @author THE McKilla Gorilla (accept no imposters)\n * @version 2.0\n */\nclass jSTPS {\n  // THE TRANSACTION STACK\n  // THESE VARIABLES CAN BE TURNED ON AND OFF TO SIGNAL THAT\n  // DO AND UNDO OPERATIONS ARE BEING PERFORMED\n  constructor() {\n    this.transactions = [];\n    this.mostRecentTransaction = -1;\n    this.performingDo = false;\n    this.performingUndo = false;\n  }\n  /**\n   * Tests to see if the do (i.e. redo) operation is currently being\n   * performed. If it is, true is returned, if not, false.\n   * \n   * @return true if the do (i.e. redo) operation is currently in the\n   * process of executing, false otherwise.\n   */\n\n\n  isPerformingDo() {\n    return this.performingDo;\n  }\n  /**\n   * Tests to see if the undo operation is currently being\n   * performed. If it is, true is returned, if not, false.\n   * \n   * @return true if the undo operation is currently in the\n   * process of executing, false otherwise.\n   */\n\n\n  isPerformingUndo() {\n    return this.performingUndo;\n  }\n  /**\n   * This  adds the transaction argument to the top of\n   * the transaction processing system stack and then executes it. Note that it does\n   * When this method has completed transaction will be at the top \n   * of the stack, it will have been completed, and the counter have\n   * been moved accordingly.\n   * \n   * @param transaction The custom transaction to be added to\n   * the transaction processing system stack and executed.\n   */\n\n\n  addTransaction(transaction) {\n    // ARE THERE OLD UNDONE TRANSACTIONS ON THE STACK THAT FIRST\n    // NEED TO BE CLEARED OUT, i.e. ARE WE BRANCHING?\n    console.log(this.transactions);\n\n    if (this.mostRecentTransaction < 0 || this.mostRecentTransaction < this.transactions.length - 1) {\n      for (var i = this.transactions.length - 1; i > this.mostRecentTransaction; i--) {\n        this.transactions.pop();\n      }\n    }\n\n    console.log(this.transactions); // AND NOW ADD THE TRANSACTION\n\n    this.transactions.push(transaction); // AND EXECUTE IT\n\n    this.doTransaction();\n  }\n  /**\n   * This  executes the transaction at the location of the counter,\n   * then moving the TPS counter. Note that this may be the transaction\n   * at the top of the TPS stack or somewhere in the middle (i.e. a redo).\n   */\n\n\n  doTransaction() {\n    if (this.hasTransactionToRedo()) {\n      this.performingDo = true;\n      var transaction = this.transactions[this.mostRecentTransaction + 1];\n      transaction.doTransaction();\n      this.mostRecentTransaction++;\n      this.performingDo = false;\n    }\n  }\n  /**\n   * This  checks to see if there is a transaction to undo. If there\n   * is it will return it, if not, it will return null.\n   * \n   * @return The transaction that would be executed if undo is performed, if\n   * there is no transaction to undo, null is returned.\n   */\n\n\n  peekUndo() {\n    if (this.hasTransactionToUndo()) {\n      return this.transactions[this.mostRecentTransaction];\n    } else return null;\n  }\n  /**\n   * This  checks to see if there is a transaction to redo. If there\n   * is it will return it, if not, it will return null.\n   * \n   * @return The transaction that would be executed if redo is performed, if\n   * there is no transaction to undo, null is returned.\n   */\n\n\n  peekDo() {\n    if (this.hasTransactionToRedo()) {\n      return this.transactions[this.mostRecentTransaction + 1];\n    } else return null;\n  }\n  /**\n   * This  gets the most recently executed transaction on the \n   * TPS stack and undoes it, moving the TPS counter accordingly.\n   */\n\n\n  undoTransaction() {\n    if (this.hasTransactionToUndo()) {\n      this.performingUndo = true;\n      var transaction = this.transactions[this.mostRecentTransaction];\n      transaction.undoTransaction();\n      this.mostRecentTransaction--;\n      this.performingUndo = false;\n    }\n  }\n  /**\n   * This method clears all transactions from the TPS stack\n   * and resets the counter that keeps track of the location\n   * of the top of the stack.\n   */\n\n\n  clearAllTransactions() {\n    // REMOVE ALL THE TRANSACTIONS\n    this.transactions = []; // MAKE SURE TO RESET THE LOCATION OF THE\n    // TOP OF THE TPS STACK TOO\n\n    this.mostRecentTransaction = -1;\n  }\n  /**\n   * Accessor method that returns the number of transactions currently\n   * on the transaction stack. This includes those that may have been\n   * done, undone, and redone.\n   * \n   * @return The number of transactions currently in the transaction stack.\n   */\n\n\n  getSize() {\n    return this.transactions.length;\n  }\n  /**\n   * This method returns the number of transactions currently in the\n   * transaction stack that can be redone, meaning they have been added\n   * and done, and then undone.\n   * \n   * @return The number of transactions in the stack that can be redone.\n   */\n\n\n  getRedoSize() {\n    return this.getSize() - this.mostRecentTransaction - 1;\n  }\n  /**\n   * This method returns the number of transactions currently in the \n   * transaction stack that can be undone.\n   * \n   * @return The number of transactions in the transaction stack that\n   * can be undone.\n   */\n\n\n  getUndoSize() {\n    return this.mostRecentTransaction + 1;\n  }\n  /**\n   * This method tests to see if there is a transaction on the stack that\n   * can be undone at the time this  is called.\n   * \n   * @return true if an undo operation is possible, false otherwise.\n   */\n\n\n  hasTransactionToUndo() {\n    return this.mostRecentTransaction >= 0;\n  }\n  /**\n   * This method tests to see if there is a transaction on the stack that\n   * can be redone at the time this  is called.\n   * \n   * @return true if a redo operation is possible, false otherwise.\n   */\n\n\n  hasTransactionToRedo() {\n    return this.mostRecentTransaction < this.transactions.length - 1;\n  }\n  /**\n   * This method builds and returns a textual summary of the current\n   * Transaction Processing System, this includes the toString of\n   * each transaction in the stack.\n   * \n   * @return A textual summary of the TPS.\n   */\n\n\n  toString() {\n    var text = \"--Number of Transactions: \" + this.transactions.size() + \"\\n\";\n    text += \"--Current Index on Stack: \" + this.mostRecentTransaction + \"\\n\";\n    text += \"--Current Transaction Stack:\\n\";\n\n    for (var i = 0; i <= this.mostRecentTransaction; i++) {\n      var jT = this.transactions[i];\n      text += \"----\" + jT.toString() + \"\\n\";\n    }\n\n    return text;\n  }\n\n}\n\nexport default jSTPS;","map":{"version":3,"sources":["/home/tom/Desktop/todo_hw2/src/jTPS-master/test/jtps/jSTPS.js"],"names":["jSTPS","constructor","transactions","mostRecentTransaction","performingDo","performingUndo","isPerformingDo","isPerformingUndo","addTransaction","transaction","console","log","length","i","pop","push","doTransaction","hasTransactionToRedo","peekUndo","hasTransactionToUndo","peekDo","undoTransaction","clearAllTransactions","getSize","getRedoSize","getUndoSize","toString","text","size","jT"],"mappings":"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","sourcesContent":["/**\n * jTPS.java\n * \n * This class is used for managing an abstract transaction processing\n * system for the purpose of managing an undo/redo system for an\n * application. Note that one must specify all work done via custom\n * transactions.\n * \n * @author THE McKilla Gorilla (accept no imposters)\n * @version 2.0\n */\nclass jSTPS {\n    // THE TRANSACTION STACK\n    \n    // THESE VARIABLES CAN BE TURNED ON AND OFF TO SIGNAL THAT\n    // DO AND UNDO OPERATIONS ARE BEING PERFORMED\n    constructor(){\n        this.transactions = [];\n        this.mostRecentTransaction = -1;\n        this.performingDo = false;\n        this.performingUndo = false;\n    }\n\n    /**\n     * Tests to see if the do (i.e. redo) operation is currently being\n     * performed. If it is, true is returned, if not, false.\n     * \n     * @return true if the do (i.e. redo) operation is currently in the\n     * process of executing, false otherwise.\n     */\n    isPerformingDo(){\n        return this.performingDo;\n    }\n    \n    /**\n     * Tests to see if the undo operation is currently being\n     * performed. If it is, true is returned, if not, false.\n     * \n     * @return true if the undo operation is currently in the\n     * process of executing, false otherwise.\n     */\n    isPerformingUndo() {\n        return this.performingUndo;\n    }\n    \n    /**\n     * This  adds the transaction argument to the top of\n     * the transaction processing system stack and then executes it. Note that it does\n     * When this method has completed transaction will be at the top \n     * of the stack, it will have been completed, and the counter have\n     * been moved accordingly.\n     * \n     * @param transaction The custom transaction to be added to\n     * the transaction processing system stack and executed.\n     */\n    addTransaction(transaction) {\n        // ARE THERE OLD UNDONE TRANSACTIONS ON THE STACK THAT FIRST\n        // NEED TO BE CLEARED OUT, i.e. ARE WE BRANCHING?\n        console.log(this.transactions)\n        if ((this.mostRecentTransaction < 0)|| (this.mostRecentTransaction < (this.transactions.length-1))) {\n            for (var i = this.transactions.length-1; i > this.mostRecentTransaction; i--) {\n                this.transactions.pop();\n            }\n        }\n        console.log(this.transactions);\n        // AND NOW ADD THE TRANSACTION\n        this.transactions.push(transaction);\n\n        // AND EXECUTE IT\n        this.doTransaction();        \n    }\n\n    /**\n     * This  executes the transaction at the location of the counter,\n     * then moving the TPS counter. Note that this may be the transaction\n     * at the top of the TPS stack or somewhere in the middle (i.e. a redo).\n     */\n    doTransaction() {\n        if (this.hasTransactionToRedo()) {\n            this.performingDo = true;\n            var transaction = this.transactions[this.mostRecentTransaction+1];\n            transaction.doTransaction();\n            this.mostRecentTransaction++;\n            this.performingDo = false;\n        }\n    }\n    \n    /**\n     * This  checks to see if there is a transaction to undo. If there\n     * is it will return it, if not, it will return null.\n     * \n     * @return The transaction that would be executed if undo is performed, if\n     * there is no transaction to undo, null is returned.\n     */\n    peekUndo() {\n        if (this.hasTransactionToUndo()) {\n            return this.transactions[this.mostRecentTransaction];\n        }\n        else\n            return null;\n    }\n    \n    /**\n     * This  checks to see if there is a transaction to redo. If there\n     * is it will return it, if not, it will return null.\n     * \n     * @return The transaction that would be executed if redo is performed, if\n     * there is no transaction to undo, null is returned.\n     */    \n    peekDo() {\n        if (this.hasTransactionToRedo()) {\n            return this.transactions[this.mostRecentTransaction+1];\n        }\n        else\n            return null;\n    }\n\n    /**\n     * This  gets the most recently executed transaction on the \n     * TPS stack and undoes it, moving the TPS counter accordingly.\n     */\n    undoTransaction() {\n        if (this.hasTransactionToUndo()) {\n            this.performingUndo = true;\n            var transaction = this.transactions[this.mostRecentTransaction];\n            transaction.undoTransaction();\n            this.mostRecentTransaction--;\n            this.performingUndo = false;\n        }\n    }\n\n    /**\n     * This method clears all transactions from the TPS stack\n     * and resets the counter that keeps track of the location\n     * of the top of the stack.\n     */\n    clearAllTransactions() {\n        // REMOVE ALL THE TRANSACTIONS\n        this.transactions = [];\n        \n        // MAKE SURE TO RESET THE LOCATION OF THE\n        // TOP OF THE TPS STACK TOO\n        this.mostRecentTransaction = -1;        \n    }\n    \n    /**\n     * Accessor method that returns the number of transactions currently\n     * on the transaction stack. This includes those that may have been\n     * done, undone, and redone.\n     * \n     * @return The number of transactions currently in the transaction stack.\n     */\n    getSize() {\n        return this.transactions.length;\n    }\n    \n    /**\n     * This method returns the number of transactions currently in the\n     * transaction stack that can be redone, meaning they have been added\n     * and done, and then undone.\n     * \n     * @return The number of transactions in the stack that can be redone.\n     */\n    getRedoSize() {\n        return this.getSize() - this.mostRecentTransaction - 1;\n    }\n\n    /**\n     * This method returns the number of transactions currently in the \n     * transaction stack that can be undone.\n     * \n     * @return The number of transactions in the transaction stack that\n     * can be undone.\n     */\n    getUndoSize() {\n        return this.mostRecentTransaction + 1;\n    }\n    \n    /**\n     * This method tests to see if there is a transaction on the stack that\n     * can be undone at the time this  is called.\n     * \n     * @return true if an undo operation is possible, false otherwise.\n     */\n    hasTransactionToUndo() {\n        return this.mostRecentTransaction >= 0;\n    }\n    \n    /**\n     * This method tests to see if there is a transaction on the stack that\n     * can be redone at the time this  is called.\n     * \n     * @return true if a redo operation is possible, false otherwise.\n     */\n    hasTransactionToRedo() {\n        return this.mostRecentTransaction < (this.transactions.length-1);\n    }\n        \n    /**\n     * This method builds and returns a textual summary of the current\n     * Transaction Processing System, this includes the toString of\n     * each transaction in the stack.\n     * \n     * @return A textual summary of the TPS.\n     */\n    toString(){\n        var text = \"--Number of Transactions: \" + this.transactions.size() + \"\\n\";\n        text += \"--Current Index on Stack: \" + this.mostRecentTransaction + \"\\n\";\n        text += \"--Current Transaction Stack:\\n\";\n        for (var i = 0; i <= this.mostRecentTransaction; i++) {\n            var jT = this.transactions[i];\n            text += \"----\" + jT.toString() + \"\\n\";\n        }\n        return text;\n    }\n}\n\nexport default jSTPS;\n"]},"metadata":{},"sourceType":"module"}